<html>
<head>
	<title>DigSimp</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<meta name="description" content="Boolean Expression Minimization">
	<meta name="keywords" content="Quine-McCluskey, Karnaugh, Digital, Boolean, Expression">

	<script src="https://jafl.github.io/yui3/build/yui/yui-min.js"></script>

	<style type="text/css">
	.intro { width:50%; }
	.instr { font-size:80%; color:#666; }
	.debug { display:none; }
	#count { width:3em; }
	#main td { vertical-align:top; }
	#truth { margin-right:3em; }
	#modify { margin-top:0; }
	</style>
</head>

<body>

<!-- https://codepo8.github.io/css-fork-on-github-ribbon/ -->
<style>
#forkongithub a{background:#000;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}
#forkongithub a:hover{background:#c11;color:#fff;}
#forkongithub a::before,#forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}
#forkongithub a::after{bottom:1px;top:auto;}
@media screen and (min-width:800px){#forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:60px;right:-60px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}
</style>
<span id="forkongithub"><a href="https://github.com/jafl/digsimp">Fork me on GitHub</a></span>

<h1>Digital Logic Simplification</h1>

<p class="intro">This page generates a Boolean expression from a truth table using the Quine-McCluskey algorithm.  The results are the same as what you would get from a Karnaugh Map, but it works for more than 4 variables.</p>

<table id="main">
<tr><td>
	<div id="truth-container"></div>
</td><td>
	<div id="io">
		<h2 id="modify">Modify</h2>

		<form id="form-count">
			<p><label for="count">Change the number of variables:</label>
			<input type="text" id="count" value="4"><input type="submit" value="Rebuild truth table"><br>
			<span class="instr">More than 10 variables can take a long time!</span></p>
		</form>

		<p>
			<button id="fill-zero">Set all to "0"</button>
			<button id="fill-one">Set all to "1"</button>
			<button id="fill-dont-care">Set all to "Don't care"</button>
		</p>

		<p><button id="invert">Negate all values</button></p>

		<form id="form-input">
			<p><label for="">Enter a Boolean expression:</label>
			<input type="text" id="input-fn"><input type="submit" value="Fill truth table"><br>
			<span class="instr">AND is implicit , OR is + , NOT is ^ or ! , example:  A(B+^C)</span><br>
			<span class="instr debug">
				(If the results are incorrect, send me your expression and the debugging expression.)<br>
				(Debug: <span id="input-expr"></span>)
			</span></p>
		</form>

		<h2>Analyze</h2>

		<p><button id="analyze">Simplest Sum of Products</button></p>
		<p id="expr"></p>
		<p id="debug" class="instr debug"></p>

		<h2>Debug</h2>

		<p><button id="enable-debug">Enable debugging</button></p>

		<p><a href="http://newplanetsoftware.com/form/contact.php">Send feedback</a></p>
	</div>
</td></tr>
</table>

<script type="text/javascript">
YUI().use('node-style', function(Y)
{
	Y.on('domready', function()
	{
		if (YUI.Env.UA.ie)
		{
			Y.one('#enable-debug').setStyle('display', 'none');
		}
	});

	var var_min = 2,
		var_max = 26,
		var_count = 0,
		row_count = 0,
		table,
		expr = Y.one('#expr');

	function toBinary(i)
	{
		var b = i.toString(2).split('');
		while (b.length < var_count)
		{
			b.unshift('0');
		}
		return b;
	}

	function fromBinary(b)
	{
		return parseInt(b.join(''), 2);
	}

	function valueMenu(i)
	{
		return table.get('children')
					.item(1).get('children')
					.item(i).one('select');
	}

	function value(i)
	{
		return valueMenu(i).get('value');
	}

	Y.on('click', function(e)
	{
		Y.all('.debug').setStyle('display', 'inherit');
	},
	'#enable-debug');

	// generate truth table

	function buildTruthTable()
	{
		var_count = parseInt(Y.one('#count').get('value'), 10);
		if (!Y.Lang.isNumber(var_count) || var_count < var_min || var_max < var_count)
		{
			alert('The number of variables must be between 2 and 26, inclusive.');
			return;
		}

		var s = '<table id="truth"><thead>';

		for (var i=0; i<var_count; i++)
		{
			s += '<th>' + String.fromCharCode(65+i) + '</th>';
		}

		s += '<th>Value</th></thead><tbody>';

		var options =
			'<option>0</option>' +
			'<option>1</option>' +
			'<option>X</option>';

		row_count = Math.pow(2, var_count);
		for (var i=0; i<row_count; i++)
		{
			var b = toBinary(i);

			s += '<tr>';

			for (var j=0; j<var_count; j++)
			{
				s += '<td>' + b[j] + '</td>';
			}

			s += '<td><select id="value-' + i + '">' + options + '</select>';
			s += '</tr>';
		}

		s += '</tbody></table>';
		Y.one('#truth-container').set('innerHTML', s);
		table = Y.one('#truth');
	}

	Y.on('submit', function(e)
	{
		e.halt();
		buildTruthTable();
	},
	'#form-count');

	Y.on('domready', buildTruthTable);

	// fill truth table

	Y.on('submit', function(e)
	{
		e.halt();

		// convert Boolean expression to JavaScript code

		var s = Y.one('#input-fn').get('value')
				 .toUpperCase()
				 .replace(/\s+/g, '')
				 .replace(/\+/g, '||')
				 .replace(/\^/g, '!');

		// replace() never considers the same character twice,
		// so AB^C won't convert correctly in a single pass.

		while (1)
		{
			var s1 = s.replace(/([\)A-Z])([\(!A-Z])/g, '$1&&$2');
			if (s1 == s)
			{
				break;
			}
			s = s1;
		}

		// display result for debugging

		Y.one('#input-expr').set('innerHTML', s.replace(/\|\|/g, ' || '));

		// populate truth table

		try
		{
			for (var i=0; i<row_count; i++)
			{
				var b = toBinary(i);
				for (var j=0; j<var_count; j++)
				{
					eval('var ' + String.fromCharCode(65+j) + '=' + b[j]);
				}

				valueMenu(i).set('value', eval(s) ? '1' : '0');
			}
		}
		catch (e)
		{
			alert('Unable to evaluate the expression that you entered.  Please check that you have the correct number of variables in the truth table and that the syntax is correct.');
		}
	},
	'#form-input');

	// invert truth table

	Y.on('click', function(e)
	{
		table.all('select').each(function(e)
		{
			var value = e.get('value');
			if (value != 'X')
			{
				e.set('value', value == '1' ? '0' : '1');
			}
		});
	},
	'#invert');

	// fill truth table

	Y.on('click', function(e)
	{
		table.all('select').set('value', '0');
	},
	'#fill-zero');

	Y.on('click', function(e)
	{
		table.all('select').set('value', '1');
	},
	'#fill-one');

	Y.on('click', function(e)
	{
		table.all('select').set('value', 'X');
	},
	'#fill-dont-care');

	// Quine-McCluskey

	function hasPI(
		/* array */	pi,
		/* array */	b)
	{
		b = b.join('');
		for (var i=0; i<pi.length; i++)
		{
			if (b == pi[i].join(''))
			{
				return true;
			}
		}

		return false;
	}

	Y.on('click', function(e)
	{
		var debug = '';

		// find 1's (and X's)

		var pi    = [],
			terms = [];

		for (var i=0; i<row_count; i++)
		{
			var v = value(i);
			if (v !== '0')
			{
				var b = toBinary(i);
				pi.push(b);
				if (v === '1')
				{
					terms.push(b);
				}
			}
		}

		// generate prime implicants

		do
		{
			debug += '<hr>' + pi.join('<br>');

			var pi2     = [];
			var changed = false;
			var covered = [];
			for (var i=0; i<pi.length; i++)
			{
				var b       = pi[i];
				var matched = false;
				for (var j=pi.length-1; j>i; j--)
				{
					var b1 = pi[j];
					var d  = -1;
					for (var k=0; k<var_count; k++)
					{
						var different = (b[k] !== b1[k]);
						if (different && d == -1)
						{
							d = k;
						}
						else if (different)
						{
							d = -1;
							break;
						}
					}

					if (d >= 0)
					{
						var b2 = b.slice(0);
						b2[d]  = 'X';
						if (!hasPI(pi2, b2))
						{
							pi2.push(b2);
						}
						changed = covered[j] = matched = true;
					}
				}

				if (!matched && !covered[i])
				{
					pi2.push(b);
				}
			}

			pi = pi2;
		}
			while (changed);

		// compute coverage of each 1 in truth table

		var coverage = [];
		for (var i=0; i<terms.length; i++)
		{
			var t = terms[i];
			for (var j=0; j<pi.length; j++)
			{
				var b      = pi[j];
				var covers = true;
				for (var k=0; k<var_count; k++)
				{
					if (b[k] !== t[k] && b[k] !== 'X')
					{
						covers = false;
						break;
					}
				}

				if (covers)
				{
					coverage[i] = (coverage[i] || 0) + 1;
				}
			}
		}

		debug += '<hr>' + coverage.join(',<WBR>');

		// remove unnecessary prime implicants

		for (var i=pi.length-1; i>=0; i--)
		{
			var b     = pi[i],
				c     = [],
				extra = true;
			for (var j=0; j<terms.length; j++)
			{
				var t      = terms[j],
					covers = true;
				for (var k=0; k<var_count; k++)
				{
					if (b[k] !== t[k] && b[k] !== 'X')
					{
						covers = false;
						break;
					}
				}

				if (covers)
				{
					c.push(j);
					if (coverage[j] == 1)
					{
						extra = false;
					}
				}
			}

			if (extra)
			{
				pi.splice(i,1);
				for (var j=0; j<c.length; j++)
				{
					coverage[ c[j] ]--;
				}
			}
		}

		debug += '<hr>' + pi.join('<br>');
		debug += '<hr>' + coverage.join(',<WBR>');

		// display result

		var s = '';
		for (var i=0; i<pi.length; i++)
		{
			if (i > 0)
			{
				s += ' + ';
			}

			var b = pi[i];
			for (var j=0; j<var_count; j++)
			{
				if (b[j] !== 'X')
				{
					if (b[j] === '0')
					{
						s += '^';
					}
					s += String.fromCharCode(65+j);
				}
			}
		}

		if (!s && pi.length == 0)
		{
			s = 'Constant: 0';
		}
		else if (!s && pi.length == 1)
		{
			s = 'Constant: 1';
		}

		expr.set('innerHTML', s);

		if (!YUI.Env.UA.ie)
		{
			Y.one('#debug').set('innerHTML', debug);
		}
	},
	'#analyze');
});
</script>

</body>
</html>

<!--
^ab^c^d + a^b^c^d + a^bc^d + a^bcd + ab^c^d + abcd
	X: 1001, 1110
	B^C^D + A^B + AC
	B^C^D + A^D + AC
-->